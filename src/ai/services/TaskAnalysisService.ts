// Task Analysis Service - provides AI-based task analysis capabilities

import type { ConversationContext } from '@/context/types';
import type { HookManager } from '@/hooks/HookManager';
import type { HookContext } from '@/hooks/types';
import type { TaskManager } from '@/task/TaskManager';
import type { Task, TaskAnalysisResult } from '@/task/types';
import { logger } from '@/utils/logger';
import { PromptManager } from '../PromptManager';
import { LLMService } from './LLMService';

/**
 * Task Analysis Service
 * Provides AI-based task analysis capabilities
 * Analyzes user messages using AI to determine what tasks should be executed
 */
export class TaskAnalysisService {
  constructor(
    private llmService: LLMService,
    private taskManager: TaskManager,
    private promptManager: PromptManager,
    private hookManager: HookManager,
  ) { }

  /**
   * Analyze conversation and generate tasks
   * Returns multiple tasks (excluding reply task which is always generated by system)
   * Handles hooks for AI generation lifecycle
   *
   * @param context - Hook context containing message and conversation history
   * @returns Task array (excluding reply task)
   */
  async analyzeTask(context: HookContext): Promise<Task[]> {
    // Hook: onMessageBeforeAI
    const shouldContinue = await this.hookManager.execute('onMessageBeforeAI', context);
    if (!shouldContinue) {
      return [];
    }

    // Hook: onAIGenerationStart
    await this.hookManager.execute('onAIGenerationStart', context);

    try {
      logger.debug('[TaskAnalysisService] Analyzing task with AI...');

      // Analyze with AI to generate tasks
      // Use context.context directly since ConversationContext type is now unified
      const analysisResult = await this.analyze(context.context);

      // Hook: onAIGenerationComplete
      await this.hookManager.execute('onAIGenerationComplete', context);

      return analysisResult.tasks;
    } catch (error) {
      logger.warn('[TaskAnalysisService] Task analysis failed:', error);
      // Hook: onAIGenerationComplete (even on error)
      await this.hookManager.execute('onAIGenerationComplete', context);
      return [];
    }
  }

  /**
   * Analyze conversation and generate tasks (core logic without hooks)
   * Returns multiple tasks (excluding reply task which is always generated by system)
   *
   * @param context - Conversation context
   * @returns Task analysis result
   */
  async analyze(context: ConversationContext): Promise<TaskAnalysisResult> {
    try {
      // Build prompt for AI
      const prompt = this.buildPrompt(context);

      logger.info('[TaskAnalysisService] Starting task analysis...');
      logger.debug(`[TaskAnalysisService] User message: ${context.userMessage}`);
      logger.debug(`[TaskAnalysisService] Conversation history length: ${context.history?.length || 0}`);

      // Generate AI response using LLM service
      // For task analysis, we may want to include reasoning content to help with debugging
      // However, TaskAnalysisService's extractJSON() method can handle both cases (with or without reasoning)
      logger.debug('[TaskAnalysisService] Calling LLM service to analyze task...');
      const response = await this.llmService.generate(prompt, {
        temperature: 0.7,
        maxTokens: 1000,
        includeReasoning: false, // Don't include reasoning in response text, TaskAnalysisService will extract JSON from content
      });

      logger.info(`[TaskAnalysisService] AI response received | responseLength=${response.text.length}`);
      logger.debug(
        `[TaskAnalysisService] AI raw response: ${response.text.substring(0, 500)}${response.text.length > 500 ? '...' : ''}`,
      );

      // Parse AI response to extract task list
      const tasks = this.parseTaskListResponse(response.text, context);

      logger.info(
        `[TaskAnalysisService] ✓ Task analysis completed | taskCount=${tasks.length} | tasks=${tasks.map(t => t.type).join(', ')}`,
      );

      return {
        tasks,
        confidence: 0.8, // Default confidence, can be improved with better parsing
      };
    } catch (error) {
      const err = error instanceof Error ? error : new Error('Unknown error');
      logger.error('[TaskAnalysisService] ✗ Task analysis failed:', err);

      // Fallback: return empty task list
      return {
        tasks: [],
        confidence: 0,
        reasoning: err.message,
      };
    }
  }

  /**
   * Build prompt for AI task analysis
   * Uses PromptManager to render separate system and user templates
   * All prompt content is managed through templates, no hardcoded prompts
   */
  private buildPrompt(context: ConversationContext): string {
    // Build task types description with enhanced information(excluding reply task type)
    const taskTypes = this.taskManager.getAllTaskTypes()
      .filter(tt => tt.name.toLowerCase() !== 'reply');
    logger.debug(`[TaskAnalysisService] Building prompt with ${taskTypes.length} task type(s)`);

    const taskTypesDescription = taskTypes
      .map((tt) => {
        let desc = `- ${tt.name}: ${tt.description}`;

        // Add executor information
        desc += `\n  执行器: ${tt.executor}`;

        // Add when to use guidance if available
        if (tt.whenToUse) {
          desc += `\n  使用场景: ${tt.whenToUse}`;
        }

        // Add trigger keywords if available
        if (tt.triggerKeywords && tt.triggerKeywords.length > 0) {
          desc += `\n  触发关键词: ${tt.triggerKeywords.join(', ')}`;
        }

        // Add examples if available
        if (tt.examples && tt.examples.length > 0) {
          desc += `\n  示例消息:\n${tt.examples.map((ex) => `    - "${ex}"`).join('\n')}`;
        }

        // Add parameters if available
        if (tt.parameters) {
          const params = Object.entries(tt.parameters)
            .map(([key, def]) => `    - ${key} (${def.type}, ${def.required ? '必填' : '可选'}): ${def.description}`)
            .join('\n');
          desc += `\n  参数:\n${params}`;
        }

        return desc;
      })
      .join('\n\n');

    // Build conversation history text
    const historyText = context.history
      ? context.history.map((msg) => `${msg.role === 'user' ? '用户' : '助手'}: ${msg.content}`).join('\n')
      : '无对话历史。';

    logger.debug(`[TaskAnalysisService] Conversation history length: ${historyText.length} chars`);

    // Render system prompt template
    const systemPrompt = this.promptManager.render('task.analyze.system', {
      taskTypesDescription,
    }, { injectBase: true });

    // Render user prompt template
    const userPrompt = this.promptManager.render('task.analyze.user', {
      conversationHistory: historyText,
      userMessage: context.userMessage,
    });

    // Combine system and user prompts
    const fullPrompt = `${systemPrompt}\n\n${userPrompt}`;
    logger.debug(
      `[TaskAnalysisService] Prompt built | systemPromptLength=${systemPrompt.length} | userPromptLength=${userPrompt.length} | totalLength=${fullPrompt.length}`,
    );

    return fullPrompt;
  }

  /**
   * Extract JSON object from text that may contain reasoning content or other text
   * Tries multiple strategies to find valid JSON
   * Handles Doubao's reasoning_content format where JSON may be preceded by reasoning text
   * Now supports explicit ANSWER: marker format
   */
  private extractJSON(text: string): string | null {
    logger.debug(`[TaskAnalysisService] Extracting JSON from response | textLength=${text.length}`);
    logger.debug(
      `[TaskAnalysisService] Response preview (first 300 chars): ${text.substring(0, 300)}${text.length > 300 ? '...' : ''}`,
    );

    let jsonText = text.trim();

    // Strategy 0: Look for explicit ANSWER: marker (new format - most reliable)
    const answerMarkerMatch = jsonText.match(/ANSWER:\s*([\s\S]*?)(?:\n\n|$)/);
    if (answerMarkerMatch) {
      logger.debug('[TaskAnalysisService] Strategy 0: Found ANSWER: marker, extracting content');
      let candidate = answerMarkerMatch[1].trim();

      // Remove markdown code block if present
      const codeBlockMatch = candidate.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (codeBlockMatch) {
        candidate = codeBlockMatch[1].trim();
      }

      // Try to parse
      try {
        JSON.parse(candidate);
        logger.info('[TaskAnalysisService] ✓ Successfully extracted valid JSON using strategy 0 (ANSWER: marker)');
        logger.debug(
          `[TaskAnalysisService] Extracted JSON: ${candidate.substring(0, 200)}${candidate.length > 200 ? '...' : ''}`,
        );
        return candidate;
      } catch (parseError) {
        logger.warn(
          `[TaskAnalysisService] Strategy 0: ANSWER: marker content is not valid JSON: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`,
        );
      }
    }

    // Strategy 1: Remove markdown code block markers if present
    const jsonBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (jsonBlockMatch) {
      logger.debug('[TaskAnalysisService] Strategy 1: Found markdown code block, extracting content');
      jsonText = jsonBlockMatch[1].trim();
      // Try to parse immediately if it's a clean code block
      try {
        JSON.parse(jsonText);
        logger.info('[TaskAnalysisService] ✓ Successfully extracted valid JSON using strategy 1 (markdown code block)');
        return jsonText;
      } catch {
        // Continue to other strategies
      }
    }

    // Strategy 2: Find the last complete JSON object (most reliable for reasoning models like Doubao)
    // This handles cases where reasoning_content precedes the JSON
    // Start from the end and find the last closing brace, then find its matching opening brace
    const lastBraceIndex = jsonText.lastIndexOf('}');
    if (lastBraceIndex === -1) {
      logger.warn('[TaskAnalysisService] No closing brace found in response');
      logger.debug(`[TaskAnalysisService] Full response text: ${text}`);
      return null;
    }

    logger.debug(
      `[TaskAnalysisService] Strategy 2: Found closing brace at index ${lastBraceIndex}, searching for matching opening brace`,
    );

    // Find the matching opening brace by counting braces
    // This ensures we get a complete, balanced JSON object
    let braceCount = 0;
    let startIndex = -1;
    for (let i = lastBraceIndex; i >= 0; i--) {
      const char = jsonText[i];
      if (char === '}') {
        braceCount++;
      } else if (char === '{') {
        braceCount--;
        if (braceCount === 0) {
          startIndex = i;
          break;
        }
      }
    }

    if (startIndex !== -1) {
      const candidate = jsonText.substring(startIndex, lastBraceIndex + 1);
      logger.debug(
        `[TaskAnalysisService] Strategy 2: Extracted JSON candidate | startIndex=${startIndex} | endIndex=${lastBraceIndex} | length=${candidate.length}`,
      );
      logger.debug(`[TaskAnalysisService] Candidate JSON: ${candidate}`);

      // Try to parse it to validate it's valid JSON
      try {
        const parsed = JSON.parse(candidate);
        logger.info(
          `[TaskAnalysisService] ✓ Successfully extracted valid JSON using strategy 2 | jsonLength=${candidate.length} | keys=${Object.keys(parsed).join(',')}`,
        );
        return candidate;
      } catch (parseError) {
        const errorMsg = parseError instanceof Error ? parseError.message : 'Unknown error';
        logger.warn(`[TaskAnalysisService] Strategy 2: Extracted candidate is not valid JSON: ${errorMsg}`);
        logger.debug(
          `[TaskAnalysisService] Invalid JSON candidate: ${candidate.substring(0, 200)}${candidate.length > 200 ? '...' : ''}`,
        );
        // Not valid JSON, continue to next strategy
      }
    } else {
      logger.warn('[TaskAnalysisService] Strategy 2: Could not find matching opening brace');
    }

    // Strategy 3: Try to find JSON object by looking for common patterns
    // Look for lines that start with { and end with }
    logger.debug('[TaskAnalysisService] Strategy 3: Trying to find JSON by line pattern');
    const lines = jsonText.split('\n');
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      if (line.startsWith('{') && line.endsWith('}')) {
        try {
          JSON.parse(line);
          logger.info(
            `[TaskAnalysisService] ✓ Successfully extracted valid JSON using strategy 3 (line pattern) | jsonLength=${line.length}`,
          );
          return line;
        } catch {
          // Continue searching
        }
      }
    }

    // Strategy 4: Try simple regex match (fallback - may include extra text)
    logger.debug('[TaskAnalysisService] Strategy 4: Trying simple regex match (fallback)');
    const jsonMatch = jsonText.match(/\{[\s\S]*?\}/);
    if (jsonMatch) {
      const candidate = jsonMatch[0];
      logger.debug(`[TaskAnalysisService] Strategy 4: Found JSON using regex | length=${candidate.length}`);
      try {
        JSON.parse(candidate);
        logger.info(
          `[TaskAnalysisService] ✓ Successfully extracted valid JSON using strategy 4 (regex) | jsonLength=${candidate.length}`,
        );
        return candidate;
      } catch (parseError) {
        logger.warn(
          `[TaskAnalysisService] Strategy 4: Regex match is not valid JSON: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`,
        );
      }
    }

    logger.error('[TaskAnalysisService] ✗ Failed to extract JSON from response using all 4 strategies');
    logger.error(`[TaskAnalysisService] Full response text for debugging:\n${text}`);
    return null;
  }

  /**
   * Parse AI response to extract task list
   * Filters out reply tasks (system will always generate one)
   */
  private parseTaskListResponse(
    aiResponse: string,
    context: ConversationContext
  ): Task[] {
    const jsonText = this.extractJSON(aiResponse);
    if (!jsonText) {
      return [];
    }

    const parsed = JSON.parse(jsonText) as { tasks: Task[] };

    if (!parsed.tasks || !Array.isArray(parsed.tasks)) {
      logger.warn('[TaskAnalysisService] Invalid format: expected {"tasks": [...]}, got:', parsed);
      return [];
    }

    const taskList = parsed.tasks;

    // Convert to Task objects, validate task type exists
    return taskList.map((t: Task) => {
      if (!t.type) {
        logger.warn('[TaskAnalysisService] Missing type field in task, skipping', t);
        return null;
      }
      const taskTypeDef = this.taskManager.getTaskType(t.type);
      if (!taskTypeDef) {
        logger.warn(`[TaskAnalysisService] Unknown task type from LLM: ${t.type}, skipping`);
        return null;
      }
      return this.parseSingleTask(t, context);
    }).filter((t): t is Task => t !== null);
  }

  /**
   * Parse single task from parsed JSON object
   */
  private parseSingleTask(
    parsed: Task,
    context: ConversationContext
  ): Task {
    if (!parsed.type) {
      throw new Error('Task type (type) is required');
    }

    const taskType = this.taskManager.getTaskType(parsed.type);
    if (!taskType) {
      throw new Error(`Unknown task type: ${parsed.type}. Task type must be one of the defined types.`);
    }

    // Validate parameters (if task type defines parameters)
    if (taskType.parameters) {
      // Basic validation: check required parameters
      for (const [key, def] of Object.entries(taskType.parameters)) {
        if (def.required && !(key in (parsed.parameters || {}))) {
          logger.warn(`[TaskAnalysisService] Missing required parameter: ${key} for task type: ${parsed.type}`);
        }
      }
    }

    return {
      type: parsed.type,
      parameters: parsed.parameters || {},
      executor: taskType.executor,  // Use executor defined in task type
      metadata: {
        analyzedAt: new Date().toISOString(),
        userId: context.userId,
        groupId: context.groupId,
      },
    };
  }
}
