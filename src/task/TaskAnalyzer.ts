// Task Analyzer - uses AI to analyze conversation and generate tasks

import type { PromptManager } from '@/ai/prompt/PromptManager';
import type { LLMService } from '@/ai/services/LLMService';
import type { ConversationContext } from '@/context/types';
import { logger } from '@/utils/logger';
import type { TaskManager } from './TaskManager';
import type { Task, TaskAnalysisResult, TaskType } from './types';

/**
 * Task Analyzer - analyzes conversation using AI and generates tasks
 */
export class TaskAnalyzer {
  constructor(
    private llmService: LLMService,
    private taskManager: TaskManager,
    private promptManager: PromptManager,
  ) { }

  /**
   * Analyze conversation and generate tasks
   * Returns multiple tasks (excluding reply task which is always generated by system)
   * Returns empty array if parsing fails (upstream should ensure valid JSON output)
   */
  async analyze(context: ConversationContext): Promise<TaskAnalysisResult> {
    // Build prompt for AI
    const prompt = this.buildPrompt(context);

    logger.info('[TaskAnalyzer] Starting task analysis...');
    logger.debug(`[TaskAnalyzer] User message: ${context.userMessage}`);
    logger.debug(`[TaskAnalyzer] Conversation history length: ${context.history?.length || 0}`);

    // Generate AI response using LLM service
    logger.debug('[TaskAnalyzer] Calling LLM service to analyze task...');
    const response = await this.llmService.generate(prompt, {
      temperature: 0.7,
      maxTokens: 1000,
      includeReasoning: false, // Don't include reasoning in response text, extract JSON from content
    });

    logger.info(`[TaskAnalyzer] AI response received | responseLength=${response.text.length}`);
    logger.debug(
      `[TaskAnalyzer] AI raw response: ${response.text.substring(0, 500)}${response.text.length > 500 ? '...' : ''}`,
    );

    // Parse AI response to extract task list
    // Returns empty array if parsing fails (upstream should ensure valid JSON)
    const tasks = this.parseTaskListResponse(response.text, context);

    logger.info(
      `[TaskAnalyzer] ✓ Task analysis completed | taskCount=${tasks.length} | tasks=${tasks.map(t => t.type).join(', ')}`,
    );

    return {
      tasks,
      confidence: 0.8, // Default confidence, can be improved with better parsing
    };
  }

  /**
   * Build prompt for AI task analysis
   * Uses PromptManager to render separate system and user templates
   * All prompt content is managed through templates, no hardcoded prompts
   */
  private buildPrompt(context: ConversationContext): string {
    // Build task types description with enhanced information(excluding reply task type)
    const taskTypes = this.taskManager.getAllTaskTypes()
      .filter(tt => tt.name.toLowerCase() !== 'reply');
    logger.debug(`[TaskAnalyzer] Building prompt with ${taskTypes.length} task type(s)`);

    const taskTypesDescription = taskTypes
      .map((tt) => {
        let desc = `- ${tt.name}: ${tt.description}`;

        // Add executor information
        desc += `\n  执行器: ${tt.executor}`;

        // Add when to use guidance if available
        if (tt.whenToUse) {
          desc += `\n  使用场景: ${tt.whenToUse}`;
        }

        // Add trigger keywords if available
        if (tt.triggerKeywords && tt.triggerKeywords.length > 0) {
          desc += `\n  触发关键词: ${tt.triggerKeywords.join(', ')}`;
        }

        // Add examples if available
        if (tt.examples && tt.examples.length > 0) {
          desc += `\n  示例消息:\n${tt.examples.map((ex) => `    - "${ex}"`).join('\n')}`;
        }

        // Add parameters if available
        if (tt.parameters) {
          const params = Object.entries(tt.parameters)
            .map(([key, def]) => `    - ${key} (${def.type}, ${def.required ? '必填' : '可选'}): ${def.description}`)
            .join('\n');
          desc += `\n  参数:\n${params}`;
        }

        return desc;
      })
      .join('\n\n');

    // Build conversation history text
    const historyText = context.history
      ? context.history.map((msg) => `${msg.role === 'user' ? '用户' : '助手'}: ${msg.content}`).join('\n')
      : '无对话历史。';

    // Render system prompt template
    const systemPrompt = this.promptManager.render('task.analyze.system', {
      taskTypesDescription,
    });

    // Render user prompt template
    const userPrompt = this.promptManager.render('task.analyze.user', {
      conversationHistory: historyText,
      userMessage: context.userMessage,
    });

    // Combine system and user prompts
    const fullPrompt = `${systemPrompt}\n\n${userPrompt}`;

    logger.debug(`[TaskAnalyzer] Prompt built | fullPromptLength=${fullPrompt.length}: ${fullPrompt}`);

    return fullPrompt;
  }

  /**
   * Extract JSON object from text
   * Expects AI to output JSON after ANSWER: marker as specified in prompt
   * Returns null if parsing fails (upstream should ensure valid JSON output)
   */
  private extractJSON(text: string): string | null {
    logger.debug(`[TaskAnalyzer] Extracting JSON from response | textLength=${text.length}`);
    logger.debug(
      `[TaskAnalyzer] Response preview (first 300 chars): ${text.substring(0, 300)}${text.length > 300 ? '...' : ''}`,
    );

    const trimmedText = text.trim();

    // Look for ANSWER: marker (as specified in prompt)
    const answerMarkerMatch = trimmedText.match(/ANSWER:\s*([\s\S]*)/);
    if (!answerMarkerMatch) {
      logger.error(`[TaskAnalyzer] ✗ Failed to find ANSWER: marker in AI response`);
      logger.error(`[TaskAnalyzer] Response: ${trimmedText.substring(0, 500)}`);
      return null;
    }

    let jsonText = answerMarkerMatch[1].trim();

    // Remove markdown code block if present (though prompt says not to use it)
    const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (codeBlockMatch) {
      jsonText = codeBlockMatch[1].trim();
    }

    // Validate JSON by parsing it
    try {
      JSON.parse(jsonText);
      logger.debug(
        `[TaskAnalyzer] Extracted JSON: ${jsonText.substring(0, 200)}${jsonText.length > 200 ? '...' : ''}`,
      );
      return jsonText;
    } catch (parseError) {
      const errorMsg = parseError instanceof Error ? parseError.message : 'Unknown error';
      logger.error(`[TaskAnalyzer] ✗ Invalid JSON in AI response: ${errorMsg}`);
      logger.error(`[TaskAnalyzer] Full response text:\n${text}`);
      return null;
    }
  }

  /**
   * Parse AI response to extract task list
   * Filters out reply tasks (system will always generate one)
   * Returns empty array if parsing fails (upstream should ensure valid format)
   */
  private parseTaskListResponse(
    aiResponse: string,
    context: ConversationContext
  ): Task[] {
    const jsonText = this.extractJSON(aiResponse);
    if (!jsonText) {
      return [];
    }

    let parsed: { tasks: Task[] };
    try {
      parsed = JSON.parse(jsonText) as { tasks: Task[] };
    } catch (parseError) {
      const errorMsg = parseError instanceof Error ? parseError.message : 'Unknown error';
      logger.error(`[TaskAnalyzer] ✗ Failed to parse JSON: ${errorMsg}`);
      return [];
    }

    if (!parsed.tasks || !Array.isArray(parsed.tasks)) {
      logger.error(`[TaskAnalyzer] ✗ Invalid JSON format: expected {"tasks": [...]}, got: ${JSON.stringify(parsed)}`);
      return [];
    }

    const taskList = parsed.tasks;

    // Convert to Task objects, validate task type exists
    const validTasks: Task[] = [];
    for (const t of taskList) {
      if (!t.type) {
        continue;
      }
      const taskTypeDef = this.taskManager.getTaskType(t.type);
      if (!taskTypeDef) {
        continue;
      }
      // Validate parameters (if task type defines parameters)
      if (taskTypeDef.parameters) {
        // Basic validation: check required parameters
        for (const [key, def] of Object.entries(taskTypeDef.parameters)) {
          if (def.required && !(key in (t.parameters || {}))) {
            logger.warn(`[TaskAnalyzer] Missing required parameter: ${key} for task type: ${taskTypeDef.name}`);
          }
        }
      }
      try {
        validTasks.push(this.parseSingleTask(taskTypeDef, t.parameters || {}, context));
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        logger.warn(`[TaskAnalyzer] Failed to parse task ${t.type}: ${errorMsg}`);
      }
    }

    return validTasks;
  }

  /**
   * Parse single task from parsed JSON object
   */
  private parseSingleTask(
    taskType: TaskType,
    parameters: Record<string, unknown>,
    context: ConversationContext
  ): Task {

    return {
      type: taskType.name,
      parameters: parameters, // Use actual parameters from AI response
      executor: taskType.executor,  // Use executor defined in task type
      metadata: {
        analyzedAt: new Date().toISOString(),
        userId: context.userId,
        groupId: context.groupId,
      },
    };
  }

}
